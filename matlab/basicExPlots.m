% function basicExPlots(pout,pvector,plotnumber)
% Does some sample plots related to the explanatory example of the GPS/SA
%   pout - the structure output from a gaspMCMC function call
%   pvec - a vector of the elements of the associated MCMC chain to process
%   plotnum - which plot (1-8) to do; scalar or vector.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Author: James R. Gattiker, Los Alamos National Laboratory
% © 2008. Triad National Security, LLC. All rights reserved.
% This file was distributed as part of the GPM/SA software package
% Los Alamos Computer Code release LA-CC-06-079, C-06,114
% github.com/lanl/GPMSA
% Full copyright in the README.md in the repository
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function basicExPlots(pout,pvec,plotnum)

 % generate flags for which plots to do
  doPlot(9)=0; doPlot(plotnum)=1;
 % Extract some variables from the structure, for convenience
  model=pout.model; data=pout.data; pvals=pout.pvals(pvec);
  obsData=pout.obsData; simData=pout.simData;
  pu=model.pu; pv=model.pv; p=model.p; q=model.q;

% Plot the rhoU response in box plots, by principal component
% The rhoU indicates the degree to which the variable affects the
%  principal component. rho is in (0,1), rho=1 indicates no effect.
  if doPlot(1)
    figure(1); clf;
    % Collect the MCMC record of the betas
      bu=[pvals.betaU]';
    % Transform them into rhos
      ru = exp(-bu*0.25);
    % set up labels for the plot
      labels=[];
      for ii=1:p; labels=[labels {['x ' num2str(ii)]}]; end
      for ii=1:q; labels=[labels {['theta ' num2str(ii)]}]; end
    for ii=1:pu;
        r=ru(:,(ii-1)*(p+q)+1:ii*(p+q));
        subplot(pu,1,ii);
        boxplot(r,'labels',labels);
        title(['PC' num2str(ii)]);
    end
  end

% Examine the theta posterior calibration
% Each theta was estimated with MCMC, the result is a sample of the
%   underlying theta distribution
  if doPlot(2)
    figure(2); clf;
    t=[pvals.theta]';
    plotmatrix(t);
  end

% Predict realizations over the space of each theta.
% Vary one theta over its range, holding the remaining variables at fixed
%   values (0.5). Plot these responses.
  if doPlot(3) || doPlot(4)
    % Now the realizations over each theta
    if doPlot(3); figure(3); clf; end
    if doPlot(4); figure(4); clf; end

    % Set up grid
      grid=linspace(0,1,10); npred=length(grid);

    % Go through each theta in the model
     for ii=1:q
      % set up the thetas and the x for predictions
        theta=ones(npred,q)*0.5;
        theta(:,ii)=grid';
        xpred=ones(npred,1)*0.5;
      % predict
        pred=gPred(xpred,pvals,model,data,'wpred',theta);
      % take the mean over the realizations
        pm=squeeze(mean(pred.w,1)); % squeeze removes degenerate dims
      % Project back into the original space
        %wrm=reshape(pm,npred,pu);
        r=(simData.Ksim*pm)';
      % return to the unstandardized scale 
        v=r*simData.orig.ysd + repmat(simData.orig.ymean',npred,1);

      % plot the standardized scale
      if doPlot(3)
        figure(3);
        plotThetaEffect(r,ii,'standardized response');
      end
   
      % Plot the native scale
      if doPlot(4)
        figure(4);
        plotThetaEffect(v,ii,'response');
      end

     end
  end
  % common plot function for the previous plots
    function plotThetaEffect(y,ii,label)
      % activate the current position in a square grid
        subplot(ceil(sqrt(q)),ceil(sqrt(q)),ii);
      % plot and label
        mesh(simData.orig.time,grid,y,'MeshStyle','row');
        zlabel(label);
        xlabel('time'); ylabel(['\theta_' num2str(ii)]); 
        hidden off;
    end

% Calibrated model predictions for a data example
% Take model realizations for data x values over the calibrated theta values,
%   i.e., those that were generated by the mcmc run.
  if any(doPlot([5 6]))
    % Which data example are we looking at?
      dataPt=1;

    % generate model realizations
      pred=gPred(obsData(dataPt).x,pvals,model,data,'uvpred');

    % Separate the u and v parts of the predictions
      predv=pred.v;
      predu=pred.u;
    % go back through the basis transformation to the real variable space
      pyd=(obsData(dataPt).Dobs*predv')';
      pye=(obsData(dataPt).Kobs*predu')';

    if doPlot(5);     % do the scaled space plot
      figure(5); clf
      % calculate mean and percentile limits of the model components
      %    in the standardized space
        py=pyd+pye;
        pym =mean(py ); pylim =gQuantile(py ,[0.05 0.95]);
        pyem=mean(pye); pyelim=gQuantile(pye,[0.05 0.95]);
        pydm=mean(pyd); pydlim=gQuantile(pyd,[0.05 0.95]);
      % call the common plot function
        plotCalPreds(pyd,pye,pym,pylim,pyem,pyelim,pydm,pydlim,'std');
    end

    if doPlot(6);     % do the original scale plot
      figure(6); clf
      % calculate mean and percentile limits of the model components
      %    in the original scale
        pyd=pyd*simData.orig.ysd;
        pye=pye*simData.orig.ysd+ ...
                repmat(obsData(dataPt).orig.ymean',size(pye,1),1);
        py=pyd+pye;
        py=pyd+pye;
        pym =mean(py ); pylim =gQuantile(py ,[0.05 0.95]);
        pyem=mean(pye); pyelim=gQuantile(pye,[0.05 0.95]);
        pydm=mean(pyd); pydlim=gQuantile(pyd,[0.05 0.95]);
      % calculate mean and percentile limits of the model components
      %    in the problem space
        plotCalPreds(pyd,pye,pym,pylim,pyem,pyelim,pydm,pydlim,'orig');
    end
  end
  % Common plot code for the previous plots
    function plotCalPreds(pyd,pye,pym,pylim,pyem,pyelim,pydm,pydlim,mode)
      if strcmp(mode,'std')
         label='standardized response'; 
         y=obsData(dataPt).yStd;
      else
         label='response';
         y=obsData(dataPt).orig.y;
      end
      time=obsData(dataPt).orig.time;
      % Plot the simulation fit to the data
        h(1)=subplot(2,2,1);
        plot(time,y,'b.','LineWidth',1); hold on;
        plot(time,pyem,'g'); plot(time,pyelim,'g:');
        title('simulation'); xlabel('time'); ylabel(label);
      % Plot the total model (sim plus discrepancy) to the data
        h(2)=subplot(2,2,2);
        plot(time,y,'b.','LineWidth',1); hold on;
        plot(time,pym,'k'); plot(time,pylim,'k:');
        title('Y'); xlabel('time'); ylabel(label);
      % Just the discrepancy
        h(3)=subplot(2,2,3);
        plot(time,pydm,'c'); hold on;
        plot(time,pydlim,'c:');
        title('discrepancy'); xlabel('time'); ylabel(label);
      % Summary of all effects
        h(4)=subplot(2,2,4);
        plot(time,y,'b.','LineWidth',1); hold on;
        plot(time,pyem,'g'); plot(time,pyelim,'g:');
        plot(time,pym, 'k'); plot(time,pylim, 'k:');
        plot(time,pydm,'c'); plot(time,pydlim,'c:');
        title('summary'); xlabel('time'); ylabel(label);
      % Get the axes to all the same scale
        axisNorm(h);
    end
  
% Plot the reconstruction of a simulation example. 
%  In this case, we're taking values to predict from a particular
%  example, though in general this could be the prediction for 
%  any interpolated or extrapolated datapoint
  if any(doPlot([7 8]))
    % Set the example number
      simEx=1;
    % Predict
      pred=gPred(simData.x(simEx,1:p),pvals,model,data,'wpred', ...
           simData.x(simEx,p+1:end));

    % Transform, and get the mean and percentile bounds.
      py=(pout.simData.Ksim*pred.w')';
      pym =mean(py ); pylim =gQuantile(py ,[0.05 0.95]);

    % Plot the predicted value and confidence intervals, standardized 
      if doPlot(7); 
        figure(7); clf
        plot(simData.orig.time,simData.yStd(:,simEx),'b.','LineWidth',1);
        hold on;
        plot(simData.orig.time,pym,'k');
        plot(simData.orig.time,pylim,'k:');
        title('simulation prediction, standardized data scale');
        xlabel('time');
        ylabel('standardized response');
      end

    % Plot the prediction and intervals in the unscaled space
      if doPlot(8) 
        figure(8); clf
        % switch to the unscaled values
        py=py*simData.orig.ysd+repmat(simData.orig.ymean',size(py,1),1);
        pym=mean(py ); pylim=gQuantile(py ,[0.05 0.95]);

        plot(simData.orig.time,pout.simData.orig.y(:,simEx),'b.','LineWidth',1);
        hold on;
        plot(simData.orig.time,pym,'k');
        plot(simData.orig.time,pylim,'k:');
        title('simulation prediction');
        xlabel('time');
        ylabel('response');
    end
  end

% Plot predictions over the x range, with the input simulations and
% uncertaints overlaid.
  if doPlot(9)
    figure(9); clf
    % set the prediction grid -- should be much finer than the data
      npred=100;
      xpred=linspace(0,1,npred)';
    % do the calibrated predictions on this grid
      pred=gPred(xpred,pvals,model,data,'wpred');
    % take the mean and limits, and transform back to original space
      ypm=(simData.Ksim*squeeze(mean(pred.w,1)) )';
      ypu=(simData.Ksim*squeeze(gQuantile(pred.w,.95,1)) )';
      ypl=(simData.Ksim*squeeze(gQuantile(pred.w,.05,1)) )';
    % Set up the plotting grid, and do the plots
      [mx,my]=meshgrid(simData.orig.time,xpred);
      mesh(mx,my,ypm); hold on;
      mesh(mx,my,ypu); 
      mesh(mx,my,ypl); 
  end

end

function axisNorm(h)
  % support function, makes axes in a given set of handles equal
  ax=[-Inf -Inf -Inf -Inf];
  for ii=1:length(h)
    ax=max([ax; axis(h(ii)).*[-1 1 -1 1] ]);
  end
  ax=ax.*[-1 1 -1 1];
  for ii=1:length(h)
    axis(h(ii),ax);
  end
end